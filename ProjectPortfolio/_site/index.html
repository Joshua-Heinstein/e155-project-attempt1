<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.21">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>LED Zeppelin – E155 Final Project Portfolio Website</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ea1d7ac60288e0f1efdbc993fd8432ae.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-e31584831b205ffbb2d98406f31c2a5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">E155 Final Project Portfolio Website</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./index.html" aria-current="page"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#abstract" id="toc-abstract" class="nav-link active" data-scroll-target="#abstract">Abstract</a></li>
  <li><a href="#summary-of-our-work" id="toc-summary-of-our-work" class="nav-link" data-scroll-target="#summary-of-our-work">Summary of our work</a>
  <ul class="collapse">
  <li><a href="#initial-specifications-vs-achievement" id="toc-initial-specifications-vs-achievement" class="nav-link" data-scroll-target="#initial-specifications-vs-achievement">Initial Specifications vs Achievement</a></li>
  </ul></li>
  <li><a href="#technical-information" id="toc-technical-information" class="nav-link" data-scroll-target="#technical-information">Technical Information</a>
  <ul class="collapse">
  <li><a href="#hardware" id="toc-hardware" class="nav-link" data-scroll-target="#hardware">Hardware</a></li>
  <li><a href="#fpga" id="toc-fpga" class="nav-link" data-scroll-target="#fpga">FPGA</a></li>
  <li><a href="#mcu" id="toc-mcu" class="nav-link" data-scroll-target="#mcu">MCU</a></li>
  <li><a href="#tesla-coil" id="toc-tesla-coil" class="nav-link" data-scroll-target="#tesla-coil">Tesla Coil</a></li>
  <li><a href="#schematic" id="toc-schematic" class="nav-link" data-scroll-target="#schematic">Schematic</a></li>
  </ul></li>
  <li><a href="#quantitative-assessment" id="toc-quantitative-assessment" class="nav-link" data-scroll-target="#quantitative-assessment">Quantitative Assessment</a>
  <ul class="collapse">
  <li><a href="#fpga-1" id="toc-fpga-1" class="nav-link" data-scroll-target="#fpga-1">FPGA</a></li>
  <li><a href="#mcu-1" id="toc-mcu-1" class="nav-link" data-scroll-target="#mcu-1">MCU</a></li>
  </ul></li>
  <li><a href="#pictures-and-video" id="toc-pictures-and-video" class="nav-link" data-scroll-target="#pictures-and-video">Pictures and Video!</a></li>
  <li><a href="#code" id="toc-code" class="nav-link" data-scroll-target="#code">Code</a></li>
  <li><a href="#contacts" id="toc-contacts" class="nav-link" data-scroll-target="#contacts">Contacts</a></li>
  <li><a href="#acknowledgements" id="toc-acknowledgements" class="nav-link" data-scroll-target="#acknowledgements">Acknowledgements</a></li>
  <li><a href="#resources" id="toc-resources" class="nav-link" data-scroll-target="#resources">Resources</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">LED Zeppelin</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Joshua Heinstein and Sorin Jayaweera </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<p>MP3 audio data flows from an SD card through the DFPlayer Mini decoder, which converts digital audio to analog output at the STM32’s request via UART commands. The STM32 samples this analog signal and performs a Fast Fourier Transform to extract frequency content. The five highest-magnitude frequency components are selected and combined into a composite square wave by OR’ing five independent timer outputs, each tuned to one selected frequency. This square wave simultaneously drives the audio output (speakers or Tesla coil) and serves as input to the FPGA. The FPGA counts rising edges within 100 ms time windows to determine instantaneous frequency, mapping counts into one of 12 linearly-spaced bins from 0-2000 Hz. Each bin drives an RGB LED with brightness persistence—LEDs illuminate when their frequency is detected and fade over 2 seconds. Three momentary buttons connected to the STM32 control playback (play/pause, next track, previous track).</p>
</section>
<section id="summary-of-our-work" class="level2">
<h2 class="anchored" data-anchor-id="summary-of-our-work">Summary of our work</h2>
<p>We successfully made a music player which would read MP3 files from an SD card, and generate 1) an analog waveform for the music, 2) run a FFT on the waveform, 3) produce a square wave representing the dominant frequencies in the wave, 4) play the square wave representation of the waveform on a speaker.</p>
<p>We were unable to finish building the Tesla coil to spec, and resorted to using standard speakers. Future work would finish assembling the coil, and improve the fidelity the output square wave with filters.</p>
<p>The circuitry is currently on a breadboard, and has yet to be put onto a protoboard.</p>
<section id="initial-specifications-vs-achievement" class="level3">
<h3 class="anchored" data-anchor-id="initial-specifications-vs-achievement">Initial Specifications vs Achievement</h3>
<p>We set out on this project with the initial goal of having a functioning musical tesla coil. This goal was not achieved.</p>
<p>At the beginning, we had set out the following success criteria:</p>
<p>To accomplish the project, we must have a system which: Reads and transmits the music files from the microSD card Play music from the previous device through the MCU and FPGA Tesla Coil Component creates high voltage sparks The sparks toggle on and off at an appropriate frequency to somewhat match the music The music is audible to humans with a reasonably safe distance from the tesla coil</p>
<p>Our achievements are as follows: We successfully read and communicate MP3 files from a microSD via the DFPlayer mini, which is controlled by USART commands from the MCU. This goal was met. We run a compression and conversion from analog voltages to square waves with the top 10 most powerful frequencies included, which are sufficient to drive a MOSFET (for the goal of a tesla coil) or a regular speaker (actually implemented). This goal was met. We did not successfully build a tesla coil. This goal was not met, but was also removed from our specification midway through the project. The signal that is intended to drive the coil, currently driving a speaker, does properly match the music with large losses (very few frequencies are kept). We didn’t build the coil, so there are no sparks. This goal was met with a caveat. The music is audible, and driven from a speaker. This goal was met.</p>
</section>
</section>
<section id="technical-information" class="level2">
<h2 class="anchored" data-anchor-id="technical-information">Technical Information</h2>
<section id="hardware" class="level3">
<h3 class="anchored" data-anchor-id="hardware">Hardware</h3>
<p>For all materials required to impliment this project, see <a href="https://docs.google.com/spreadsheets/d/1PpSJdLAugirSvzMBNCxlbClIvVkomqqivFFxnm3hw_g/edit?gid=809660558#gid=809660558">Bill Of Materials</a></p>
<p>New Hardware includes: The Tesla Coil</p>
<p>Frequency Display We use twelve LEDs, which are either Red, Green, or Blue. Each LED requires 3.3V supply, and their brightness is controlled by PWM. Current limiting: 220Ω resistors per channel. Total current draw: ~720 mA at full brightness. Audio Source We use the DFPlayer Mini, an MP3 decoder module with an onboard DAC that supports SD cards up to 32 GB.The Mini is controlled via UART at 9600 baud. It spits out an analog audio output (0.6 Vpp). It takes 3.3V power from STM32.</p>
<p>The primary new hardware is the Tesla coil, which is made of two stages: The primary stage has DC power fed through a buck converter, into a resonant circuit from a capacitor and the primary coil winding. The secondary stage is not electrically connected, but is situated within range of the electromagnetic field produced by the first stage. This is made of a large inductor and a topload (a ball of aluminum), and acts as the second resonant circuit.</p>
<p>In addition to the Tesla Coil, we integrated the DFPlayer Mini, which communicates via USART, and a 3 color 12 LED display. The DFPlayer came with poor documentation riddled with typos and few resources available regarding integration with MCUs besides arduinos.</p>
</section>
<section id="fpga" class="level3">
<h3 class="anchored" data-anchor-id="fpga">FPGA</h3>
<section id="overview" class="level4">
<h4 class="anchored" data-anchor-id="overview">Overview</h4>
<p>We used the iCE40 UP5K.</p>
<p>MP3 audio data flows from an SD card through the DFPlayer Mini decoder, which converts digital audio to analog output at the STM32’s request via UART commands. The STM32 samples this analog signal and performs a Fast Fourier Transform to extract frequency content. The five highest-magnitude frequency components are selected and combined into a composite square wave by OR’ing five independent timer outputs, each tuned to one selected frequency. This square wave simultaneously drives the audio output (speakers or Tesla coil) and serves as input to the FPGA. The FPGA counts rising edges within 100 ms time windows to determine instantaneous frequency, mapping counts into one of 12 linearly-spaced bins from 0-2000 Hz. Each bin drives an RGB LED with brightness persistence—LEDs illuminate when their frequency is detected and fade over 2 seconds. Three momentary buttons connected to the STM32 control playback (play/pause, next track, previous track).</p>
<p>Led Control Each bucket maintains a 16-bit persistence timer counting down from 65535 (2.05 seconds at 48 MHz with 1024 prescaler). When a frequency is detected, the corresponding timer resets to maximum. Timer values map logarithmically to PWM duty cycle for LED brightness, creating exponential decay. A no-signal LED illuminates when all pulse counters read zero for one full window.</p>
</section>
<section id="block-diagram" class="level4">
<h4 class="anchored" data-anchor-id="block-diagram">Block Diagram</h4>
<p>The block diagram for this project shows the MCU communicating with the DFPlayer Mini over UART on pins PA9 (TX) and PA10 (RX). As an analog signal leaves the DFPlayer to drive the speaker, it is read by pin PA5 on the MCU. The MCU reads it using its ADC, and runs an FFT on the signal, producing a square wave composed of the 5 most dominant frequencies. The FPGA reads this on pin P12 and outputs PWM waves to 12 LEDs with a duty cycle related to how prevalent the corresponding LED’s frequency is in a 2 second window.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/blockdiagram2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: FPGA Block Diagram</figcaption>
</figure>
</div>
</section>
<section id="state-transition-table" class="level4">
<h4 class="anchored" data-anchor-id="state-transition-table">State Transition Table</h4>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/statetransition.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: State Transition Table</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/statetransition2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: State Transition Diagram</figcaption>
</figure>
</div>
</section>
</section>
<section id="mcu" class="level3">
<h3 class="anchored" data-anchor-id="mcu">MCU</h3>
<section id="overview-1" class="level4">
<h4 class="anchored" data-anchor-id="overview-1">Overview</h4>
<p>The STM32L432KC MCU is the workhorse of this project. It operates three concurrent tasks: DFPlayer control, audio processing, and user input handling. The MCU has three user input buttons: Play/Pause the current song, move to the next song, and return to the previous. It sends USART commands based on these to the DFPlayer mini, and then converts the analog audio signal to a square wave for use further down the line. Software Architecture: Main loop polls button states with software debouncing (10 ms) and issues UART commands to the DFPlayer (9600 baud). Audio processing runs in a timer interrupt at 8 kHz sampling rate. DFPlayer Mini configuration: The DFPlayer mini takes long byte sequence commands to configure, in the structure: 0x7E 0xFF 0x06 CMD PAR1 PAR2 CHECKSUM 0xEF. We are using the functionality for Play (0x0D), Pause (0x0E), Next (0x01), Previous (0x02), Volume (0x06). FFT: Audio samples are buffered in a 512-sample circular buffer. Every 64 ms (512 samples at 8 kHz), the CMSIS-DSP library arm_rfft_fast_f32 computes a 512-point real FFT with Hann windowing. Output provides 256 frequency bins with 15.625 Hz resolution (8000 Hz / 512). Magnitude is computed via arm_cmplx_mag_f32, and the top 5 non-DC bins are identified by sorting.</p>
<p>Square wave: Five hardware timers (TIM2/3/15/16/17) generate independent square waves at the detected frequencies. Each timer’s ARR register updates when a new frequency is identified. Timer outputs connect to a hardware OR gate (external logic) before routing to both the FPGA and speaker amplifier. Update rate: 15.625 Hz (once per FFT frame).</p>
<p>Configuring the Audio Source</p>
<p>We are using the DFPlayer Mini mp3 to analog decoding module. This module is controlled via USART messages for various functionality, including changing songs, redoing, and traversing within a song.</p>
<p>Outputting a square wave The square wave is the signal intended to control the Tesla Coil and or Speakers. This square wave is generated by performing an Fast Fourier Transform on the analog signal from the Audio Source. The top 5 (although replaceable with any N) most powerful frequencies are selected and sent out in the square wave. Each frequency has its own timer signal, all of which are or’d together. In this way, there is a clean square wave output that still encodes the dominant information from the music.</p>
</section>
</section>
<section id="tesla-coil" class="level3">
<h3 class="anchored" data-anchor-id="tesla-coil">Tesla Coil</h3>
<p>The calculations for our prototype Tesla Coil can be found here: <a href="https://docs.google.com/spreadsheets/d/109igXfaqVS3fRfR9IeJHc-fNuv5fjdSeQtVGv-yPBRM/edit?usp=sharing">Tesla Coil Calculations</a></p>
</section>
<section id="schematic" class="level3">
<h3 class="anchored" data-anchor-id="schematic">Schematic</h3>
<p>The MCU is powered over USB, and three push buttons are connected to the MCU to trigger the MCU to send commands for previous song (PA8), play/pause (PA6), and next song (PB7).</p>
<p>The DFPlayer requires a separate 5V power source to supply enough power to the speaker.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Schematic.jpg" class="img-fluid figure-img"></p>
<figcaption>Figure 4: Full System Schematic</figcaption>
</figure>
</div>
</section>
</section>
<section id="quantitative-assessment" class="level2">
<h2 class="anchored" data-anchor-id="quantitative-assessment">Quantitative Assessment</h2>
<section id="fpga-1" class="level3">
<h3 class="anchored" data-anchor-id="fpga-1">FPGA</h3>
<p>The FPGA samples incoming square waves for 100 ms, counting falling edges. Each edge count corresponds to 10 Hz (1 edge / 0.1 s = 10 Hz). This gives an absolute frequency resolution of ±10 Hz due to integer edge count quantization. Frequency bucket mapping: Bucket 0: 0-16 edges → 0-160 Hz Bucket 1: 17-33 edges → 170-330 Hz Bucket 2: 34-50 edges → 340-500 Hz Bucket 3: 51-67 edges → 510-670 Hz Bucket 4: 68-83 edges → 680-830 Hz Bucket 5: 84-100 edges → 840-1000 Hz Bucket 6: 101-117 edges → 1010-1170 Hz Bucket 7: 118-134 edges → 1180-1340 Hz Bucket 8: 135-150 edges → 1350-1500 Hz Bucket 9: 151-167 edges → 1510-1670 Hz Bucket 10: 168-184 edges → 1680-1840 Hz Bucket 11: &gt;184 edges → &gt;1840 Hz</p>
<p>Because there are few LEDs, the 10 Hz quantization is not a significant limitation for the display, since the widths of the bins are so much larger.</p>
</section>
<section id="mcu-1" class="level3">
<h3 class="anchored" data-anchor-id="mcu-1">MCU</h3>
<section id="latency" class="level4">
<h4 class="anchored" data-anchor-id="latency">Latency</h4>
<p>The MCU’s ADC needs 256 samples to run each iteration of the FFT. At 8000 hz, this corresponds to 32 ms. On average, a signal will turn to become a frequency in the middle of a window, so 1.5 would need to be taken on average to capture the frequency and properly output a square wave, which is ~48 ms latency. Computation time is negligible relative to waiting for samples to arrive, given the PLL clock runs at 80 MHz.</p>
<p>####FFT Accuracy The sampling rate is 8 kHz, which sets a maximum representable frequency of 4 kHz (Nyquist limit). The 256-sample Cooley-Tukey FFT produces frequency bins spaced 31.25 Hz apart (8000 Hz / 256 = 31.25 Hz). This FFT size was chosen to balance frequency resolution against latency—doubling to 512 samples would halve the bin spacing to 15.6 Hz but double the latency to 64 ms. Configured frequency range: 100 Hz - 2000 Hz (software thresholds to reject noise and high harmonics)</p>
<p>100 Hz was artificially chosen as the minimum kept frequency, since we don’t expect our music to go below that (at worst, 40 hz drums - but we wanted to prevent sources of noise from coupling into the output square wave, given how powerful 60 hz is). Because the bins are 31.25 hz apart, the frequency accuracy while sorting them on the order of 100 hz is very low. At the worst, 100 hz would be represented as 125 hz, which is a 125/100. This is an error of 25 hz out of the total 100 hz, which is a whopping 25% inaccuracy, although this is a special case since we don’t have any sub-100 hz frequencies. The error is much less drastic for slightly higher frequencies, with a maximum of 2khz (arbitrary, also to stay within good audio range). 2 KHz is a multiple of 31.25, so the worst case would be half way to the previous frequency bin, aka 2KHz - 31.25/2 = 1983.875 Hz, which would be categorized as 1968.75 - which is relatively an error of 0.8%.</p>
</section>
<section id="synthesized-square-wave-accuracy" class="level4">
<h4 class="anchored" data-anchor-id="synthesized-square-wave-accuracy">Synthesized Square Wave Accuracy</h4>
<p>TIM15, which is used to run the output square wave, uses a 100 kHz interrupt rate - which is sufficient to perfectly capture every frequency.</p>
</section>
</section>
</section>
<section id="pictures-and-video" class="level2">
<h2 class="anchored" data-anchor-id="pictures-and-video">Pictures and Video!</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/pic.jpg" class="img-fluid figure-img"></p>
<figcaption>Figure 5: Image of Final Project</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><video src="images/vid.mp4" class="img-fluid" controls=""><a href="images/vid.mp4">Video</a></video></p>
<figcaption>Figure 6: Video Demonstration</figcaption>
</figure>
</div>
</section>
<section id="code" class="level2">
<h2 class="anchored" data-anchor-id="code">Code</h2>
<p>See our codebase of development here: <a href="https://github.com/Sorin-Jayaweera/E155">Github</a></p>
</section>
<section id="contacts" class="level2">
<h2 class="anchored" data-anchor-id="contacts">Contacts</h2>
<p>Members: Joshua Heinstein ’26 and Sorin Jayaweera ’27.</p>
<p>Joshua Heinstein <a href="https://www.linkedin.com/in/joshua-heinstein/">Linked In</a> jheinstein@g.hmc.edu</p>
<p>Sorin Jayaweera <a href="https://www.linkedin.com/in/sorin-jayaweera/">Linked In</a>, sojayaweera@g.hmc.edu</p>
<p>Sorin Jayaweera is a current Harvey Mudd student, studying a mixture of solid state and soft matter Physics, with many electrical and systems engineering related projects.</p>
<p>Joshua Heinstein is currently a Harvey Mudd student, with a focus on electrical engineering.</p>
</section>
<section id="acknowledgements" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgements">Acknowledgements</h2>
<p>Special thank you to Hackaday, for the tutorial on analog electronics to drive a tesla coil, Mathew Spencer, for assistance talking through the design specs of our project, Anthropic and OpenAI for the use of artificial programming assistance</p>
</section>
<section id="resources" class="level2">
<h2 class="anchored" data-anchor-id="resources">Resources</h2>
<p>FLEXPCB. (2024, June 17). I2S Protocol: The Beginner’s Ultimate Guide. FLEXPCB. https://flexpcb.org/i2s-protocol-the-beginners-ultimate-guide/ Flex PCB Armstrong, Z. (2022, December 11). Making the Ultimate Class-E Musical Tesla Coil. Hackaday.io. https://hackaday.io/project/188598-making-the-ultimate-class-e-musical-tesla-coil hackaday.io+1 Steve Ward [YouTube channel]. (2022, December 11). Making the Ultimate Class-E Musical Tesla Coil – official tutorial video [Video]. YouTube. https://www.youtube.com/watch?v=Hez-R-WF5P0 LabCoatz. (n.d.). Building the Ultimate Solid-State Tesla Coil (Music-Capable!): a Complete Guide. Instructables. https://www.instructables.com/Building-the-Ultimate-Solid-State-Tesla-Coil-MUSIC/ Instructables LabCoatz. (n.d.). Making the Ultimate Class-E Musical Tesla Coil (Single-FET SSTC) | a Complete Build Tutorial. Instructables. https://www.instructables.com/Making-the-Ultimate-Class-E-Musical-Tesla-Coil-Sin/ Instructables Steve Ward [YouTube channel]. (n.d.). Building the Ultimate Solid-State Tesla Coil – music-capable SSTC [Video]. YouTube. https://www.youtube.com/watch?v=zCf-PwXsG_E RIMSTAR. (n.d.). Small Spark-Gap Tesla Coil Project — Tesla Coil Spark Gap (Small). rimstar.org. https://rimstar.org/science_electronics_projects/tesla_coil_spark_gap_small.htm Steve Ward [YouTube channel]. (n.d.). Tesla Coil Demonstration Video [Video]. YouTube. https://www.youtube.com/watch?v=Ca2e3evwVK0</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>